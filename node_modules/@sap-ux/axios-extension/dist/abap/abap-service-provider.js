"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbapServiceProvider = void 0;
const posix_1 = require("node:path/posix");
const odata_service_1 = require("../base/odata-service");
const service_provider_1 = require("../base/service-provider");
const adt_catalog_service_1 = require("./adt-catalog/adt-catalog-service");
const app_index_service_1 = require("./app-index-service");
const catalog_1 = require("./catalog");
const lrep_service_1 = require("./lrep-service");
const types_1 = require("./types");
const ui5_abap_repository_service_1 = require("./ui5-abap-repository-service");
// Can't use an `import type` here. We need the classname at runtime to create object instances:
const odata_service_generator_1 = require("./adt-catalog/generators/odata-service-generator");
const ui_service_generator_1 = require("./adt-catalog/generators/ui-service-generator");
const services_1 = require("./adt-catalog/services");
const systeminfo_service_1 = require("./adt-catalog/services/systeminfo-service");
const ui5_version_service_1 = require("./ui5-version-service");
/**
 * Extension of the service provider for ABAP services.
 */
class AbapServiceProvider extends service_provider_1.ServiceProvider {
    atoSettings;
    /**
     * Maintain the public facing URL which is required for destination related flows
     */
    _publicUrl;
    /**
     * The connected system info
     */
    _systemInfo;
    /**
     * Get the name of the currently logged in user. This is the basic implementation that could be overwritten by subclasses.
     * The function returns a promise because it may be required to fetch the information from the backend.
     *
     * @returns the username
     */
    async user() {
        return (await Promise.resolve(this.defaults.auth?.username)) || (await this.getSystemInfo())?.userName;
    }
    /**
     * Get user information.
     *
     * @returns user name or undefined
     */
    async getSystemInfo() {
        if (this._systemInfo) {
            return this._systemInfo;
        }
        try {
            const systemInfoService = this.createService('', systeminfo_service_1.SystemInfoService);
            this._systemInfo = await systemInfoService.getSystemInfo();
        }
        catch (error) {
            this.log.error(`An error occurred retrieving system info: ${error}`);
        }
        return this._systemInfo;
    }
    /**
     * Set the ATO settings for the provider so that it does not try to fetch them with the first request.
     *
     * @param atoSettings ABAP Transport Organizer settings
     */
    setAtoInfo(atoSettings) {
        this.atoSettings = atoSettings;
    }
    /**
     * Get the ATO settings either locally or from the server if not yet available.
     *
     * @returns ABAP Transport Organizer settings
     */
    async getAtoInfo() {
        if (this.atoSettings) {
            return this.atoSettings;
        }
        let atoService;
        try {
            atoService = await this.getAdtService(services_1.AtoService);
            if (atoService) {
                this.atoSettings = await atoService.getAtoInfo();
            }
            else {
                this.atoSettings = {};
            }
        }
        catch (error) {
            this.atoSettings = {};
        }
        return this.atoSettings;
    }
    /**
     * Set the public facing URL, typically used for a destination related flows.
     *
     * @param host
     */
    set publicUrl(host) {
        this._publicUrl = host;
    }
    /**
     * Retrieve the public facing URL, default to Axios base URL if not configured.
     *
     * @returns string Axios baseUrl if public URL is not configured by a destination
     */
    get publicUrl() {
        return this._publicUrl || this.defaults.baseURL;
    }
    /**
     * Detect if the given configuration points to an S/4HANA Cloud system.
     *
     * @returns true if it an S/4HANA cloud system
     */
    async isAbapCloud() {
        if (this.atoSettings === undefined) {
            await this.getAtoInfo();
        }
        return this.atoSettings.tenantType === types_1.TenantType.Customer && this.atoSettings.operationsType === 'C';
    }
    /**
     * Create or get an existing instance of AdtCatalogService for fetching ADT schema.
     *
     * @returns AdtCatalogService
     */
    getAdtCatalogService() {
        if (!this.services[adt_catalog_service_1.AdtCatalogService.ADT_DISCOVERY_SERVICE_PATH]) {
            const adtCatalogService = this.createService(adt_catalog_service_1.AdtCatalogService.ADT_DISCOVERY_SERVICE_PATH, adt_catalog_service_1.AdtCatalogService);
            this.services[adt_catalog_service_1.AdtCatalogService.ADT_DISCOVERY_SERVICE_PATH] = adtCatalogService;
        }
        return this.services[adt_catalog_service_1.AdtCatalogService.ADT_DISCOVERY_SERVICE_PATH];
    }
    /**
     * Create or get an existing instance of the catalog service for the given OData version.
     *
     * @param version OData version of the requested catalog service
     * @returns an instance of the catalog service.
     */
    catalog(version) {
        let service;
        if (version === odata_service_1.ODataVersion.v2) {
            service =
                this.services[catalog_1.V2CatalogService.PATH] ??
                    this.createService(catalog_1.V2CatalogService.PATH, catalog_1.V2CatalogService);
        }
        else if (version === odata_service_1.ODataVersion.v4) {
            service =
                this.services[catalog_1.V4CatalogService.PATH] ??
                    this.createService(catalog_1.V4CatalogService.PATH, catalog_1.V4CatalogService);
        }
        else {
            throw new Error('not implemented yet');
        }
        Object.defineProperty(service, 'isAbapCloud', {
            get: this.isAbapCloud.bind(this)
        });
        return service;
    }
    /**
     * Create or get an existing instance of the UI5 ABAP repository service.
     *
     * @param alias - optional alias path on which the UI5Repository service is exposed
     * @returns an instance of the UI5 ABAP repository service.
     */
    getUi5AbapRepository(alias) {
        const path = alias ?? ui5_abap_repository_service_1.Ui5AbapRepositoryService.PATH;
        if (!this.services[path]) {
            this.services[path] = this.createService(path, ui5_abap_repository_service_1.Ui5AbapRepositoryService);
        }
        return this.services[path];
    }
    /**
     * Create or get an existing instance of the app index service.
     *
     * @returns an instance of the app index service.
     */
    getAppIndex() {
        if (!this.services[app_index_service_1.AppIndexService.PATH]) {
            this.services[app_index_service_1.AppIndexService.PATH] = this.createService(app_index_service_1.AppIndexService.PATH, app_index_service_1.AppIndexService);
        }
        return this.services[app_index_service_1.AppIndexService.PATH];
    }
    /**
     * Create or get an existing instance of design time adaptation service.
     *
     * @param alias - optional alias path on which the LREP service is exposed
     * @returns an instance of the design time adaptation service.
     */
    getLayeredRepository(alias) {
        const path = alias ?? lrep_service_1.LayeredRepositoryService.PATH;
        if (!this.services[path]) {
            this.services[path] = this.createService(path, lrep_service_1.LayeredRepositoryService);
        }
        return this.services[path];
    }
    /**
     * Retrieve singleton instance of AdtService subclass to serve the specific ADT request query.
     *
     * @example
     * ```ts
     * const transportRequestService = abapServiceProvider.getAdtService<TransportRequestService>(TransportRequestService);
     * ```
     * @param adtServiceSubclass Subclass of class AdtService, type is specified by using AdtService class constructor signature.
     * @returns Subclass type of class AdtService
     */
    async getAdtService(adtServiceSubclass) {
        const subclassName = adtServiceSubclass.name;
        if (!this.services[subclassName]) {
            // Retrieve ADT schema for the specific input AdtService subclass
            const adtCatalogService = this.getAdtCatalogService();
            const adtSchema = await adtCatalogService.getServiceDefinition(adtServiceSubclass.getAdtCatagory());
            // No ADT schema available neither locally nor from service query.
            if (!adtSchema) {
                return null;
            }
            // Create singleton instance of AdtService subclass
            this.services[subclassName] = this.createService(adtSchema.href, adtServiceSubclass);
            this.services[subclassName].attachAdtSchema(adtSchema);
        }
        return this.services[subclassName];
    }
    /**
     * Creates a singleton instance of the UI5 version service using lazy initialization.
     *
     * @returns The instance to the UI5 version service.
     */
    getUI5VersionService() {
        const path = ui5_version_service_1.UI5VersionService.PATH;
        if (!this.services[path]) {
            this.services[path] = this.createService(path, ui5_version_service_1.UI5VersionService);
        }
        return this.services[path];
    }
    /**
     * Create a UI Service generator for the given referenced object.
     *
     * @param referencedObject - referenced object (business object or abap cds view)
     * @returns a UI Service generator
     */
    async getUiServiceGenerator(referencedObject) {
        const generatorService = await this.getAdtService(services_1.GeneratorService);
        if (!generatorService) {
            throw new Error('Generators are not supported on this system');
        }
        const config = await generatorService.getUIServiceGeneratorConfig(referencedObject.uri);
        const gen = this.createService(this.getServiceUrlFromConfig(config), ui_service_generator_1.UiServiceGenerator);
        gen.configure(config, referencedObject, this.getContentType(config));
        return gen;
    }
    /**
     * Gets an OData Service generator.
     *
     * @param packageName - Name of package to be used for generated artifacts in ABAP system
     * @returns An OData Service generator
     */
    async getODataServiceGenerator(packageName) {
        const generatorService = await this.getAdtService(services_1.RapGeneratorService);
        if (!generatorService) {
            throw new Error('RAP Generator are not support on this system');
        }
        const config = await generatorService.getRAPGeneratorConfig();
        const generator = this.createService(this.getServiceUrlFromConfig(config), odata_service_generator_1.ODataServiceGenerator);
        generator.setContentType(this.getContentType(config));
        generator.configure(config, packageName || '$TMP');
        return generator;
    }
    /**
     * Collects ValueListReferences annotation values from the service metadata and annotation files.
     *
     * @param references - Service references for which metadata should be fetched.
     * @returns A list of ValueListReferences found in the metadata and annotations.
     */
    async fetchExternalServices(references) {
        const valueListReferences = [];
        const allPromises = references.map(async (reference) => {
            const { serviceRootPath, value } = reference;
            const externalServicePath = (0, posix_1.join)(serviceRootPath, value).replace('/$metadata', '');
            const externalService = this.service(externalServicePath);
            try {
                const data = await externalService.metadata();
                if (reference.type === 'value-list') {
                    valueListReferences.push({
                        type: 'value-list',
                        path: externalServicePath,
                        target: reference.target,
                        metadata: data
                    });
                }
                else if (reference.type === 'code-list') {
                    valueListReferences.push({
                        type: 'code-list',
                        path: externalServicePath,
                        metadata: data
                    });
                }
            }
            catch (error) {
                this.log.warn(`Could not fetch value list reference metadata from ${externalServicePath}, ${error.message}`);
            }
        });
        await Promise.allSettled(allPromises);
        return valueListReferences;
    }
    /**
     * Get the service URL from the generator config.
     *
     * @param config - generator config
     * @returns the service URL
     */
    getServiceUrlFromConfig(config) {
        // make code in this function defensive against undefined href
        if (Array.isArray(config.link) && !config.link[0]?.href) {
            throw new Error('No service URL found in the generator config');
        }
        const endIndex = config.link[0].href.indexOf(config.id) + config.id.length;
        return config.link[0].href.substring(0, endIndex);
    }
    /**
     * @param config - generator config
     * @returns the type of the content link from service generator config
     */
    getContentType(config) {
        const contentEndpoint = config.link?.find((link) => typeof link.href === 'string' && link.href.includes('/content'));
        return contentEndpoint.type;
    }
    /**
     * Create a service provider to lock a binding path.
     *
     * @param path - service binding path
     * @returns a service provider instance to lock the service binding
     */
    async createLockServiceBindingGenerator(path) {
        const gen = this.createService(path, ui_service_generator_1.UiServiceGenerator);
        return gen;
    }
}
exports.AbapServiceProvider = AbapServiceProvider;
//# sourceMappingURL=abap-service-provider.js.map