"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getToken = getToken;
exports.downloadZip = downloadZip;
exports.getHtml5RepoCredentials = getHtml5RepoCredentials;
exports.downloadAppContent = downloadAppContent;
const axios_1 = __importDefault(require("axios"));
const adm_zip_1 = __importDefault(require("adm-zip"));
const i18n_1 = require("../../i18n");
const api_1 = require("../services/api");
const HTML5_APPS_REPO_RUNTIME = 'html5-apps-repo-runtime';
/**
 * Get the OAuth token from HTML5 repository.
 *
 * @param {Uaa} uaa UAA credentials
 * @returns {Promise<string>} OAuth token
 */
async function getToken(uaa) {
    const auth = Buffer.from(`${uaa.clientid}:${uaa.clientsecret}`);
    const options = {
        headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Basic ' + auth.toString('base64')
        }
    };
    const uri = `${uaa.url}/oauth/token?grant_type=client_credentials`;
    try {
        const response = await axios_1.default.get(uri, options);
        return response.data['access_token'];
    }
    catch (e) {
        throw new Error((0, i18n_1.t)('error.failedToGetAuthKey', { error: e.message }));
    }
}
/**
 * Download zip from HTML5 repository.
 *
 * @param {string} token - HTML5 reposiotry token.
 * @param {string} appHostId - appHostId where content is stored.
 * @param {string} uri - URL with parameters.
 * @returns {Promise<Buffer>} File buffer content.
 */
async function downloadZip(token, appHostId, uri) {
    try {
        const response = await axios_1.default.get(uri, {
            responseType: 'arraybuffer',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + token,
                'x-app-host-id': appHostId
            }
        });
        return response.data;
    }
    catch (e) {
        throw new Error((0, i18n_1.t)('error.failedToDownloadZipFromHtml5Repo', { error: e.message }));
    }
}
/**
 * Get HTML5 repo credentials.
 *
 * @param {string} spaceGuid space guid
 * @param {ToolsLogger} logger logger to log messages
 * @returns {Promise<ServiceInfo>} credentials json object
 */
async function getHtml5RepoCredentials(spaceGuid, logger) {
    try {
        let serviceInfo = await (0, api_1.getServiceInstanceKeys)({
            spaceGuids: [spaceGuid],
            planNames: ['app-runtime'],
            names: [HTML5_APPS_REPO_RUNTIME]
        }, logger);
        if (!serviceInfo?.serviceKeys?.length) {
            const serviceName = await (0, api_1.getServiceNameByTags)(spaceGuid, ['html5-apps-repo-rt']);
            await (0, api_1.createServiceInstance)('app-runtime', HTML5_APPS_REPO_RUNTIME, serviceName, {
                logger
            });
            serviceInfo = await (0, api_1.getServiceInstanceKeys)({ names: [HTML5_APPS_REPO_RUNTIME] }, logger);
            if (!serviceInfo?.serviceKeys?.length) {
                logger.debug((0, i18n_1.t)('error.noUaaCredentialsFoundForHtml5Repo'));
                throw new Error((0, i18n_1.t)('error.cannotFindHtml5RepoRuntime'));
            }
        }
        return serviceInfo;
    }
    catch (e) {
        throw new Error((0, i18n_1.t)('error.failedToGetCredentialsFromHtml5Repo', { error: e.message }));
    }
}
/**
 * Download base app manifest.json and xs-app.json from HTML5 repository.
 *
 * @param {string} spaceGuid current space guid
 * @param {CfAppParams} parameters appName, appVersion, appHostId
 * @param {ToolsLogger} logger logger to log messages
 * @returns {Promise<AdmZip.IZipEntry[]>} manifest.json and xs-app.json
 */
async function downloadAppContent(spaceGuid, parameters, logger) {
    const { appHostId, appName, appVersion } = parameters;
    const appNameVersion = `${appName}-${appVersion}`;
    try {
        const { serviceKeys, serviceInstance } = await getHtml5RepoCredentials(spaceGuid, logger);
        const token = await getToken(serviceKeys[0]?.credentials.uaa);
        const uri = `${serviceKeys[0]?.credentials.uri}/applications/content/${appNameVersion}?pathSuffixFilter=manifest.json,xs-app.json`;
        const zip = await downloadZip(token, appHostId, uri);
        let admZip;
        try {
            admZip = new adm_zip_1.default(zip);
        }
        catch (e) {
            throw new Error((0, i18n_1.t)('error.failedToParseZipContent', { error: e.message }));
        }
        if (!admZip?.getEntries?.().length) {
            throw new Error((0, i18n_1.t)('error.noZipContentParsed'));
        }
        const zipEntry = admZip.getEntries().find((zipEntry) => zipEntry.entryName === 'manifest.json');
        if (!zipEntry) {
            throw new Error((0, i18n_1.t)('error.failedToFindManifestJsonInHtml5Repo'));
        }
        try {
            const manifest = JSON.parse(zipEntry.getData().toString('utf8'));
            return {
                entries: admZip.getEntries(),
                serviceInstanceGuid: serviceInstance.guid,
                manifest: manifest
            };
        }
        catch (e) {
            throw new Error((0, i18n_1.t)('error.failedToParseManifestJson', { error: e.message }));
        }
    }
    catch (e) {
        logger.error(e);
        throw new Error((0, i18n_1.t)('error.failedToDownloadAppContent', { spaceGuid, appName, appHostId, error: e.message }));
    }
}
//# sourceMappingURL=html5-repo.js.map