"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBusinessServiceInfo = getBusinessServiceInfo;
exports.getFDCRequestArguments = getFDCRequestArguments;
exports.getFDCApps = getFDCApps;
exports.createServiceInstance = createServiceInstance;
exports.getServiceNameByTags = getServiceNameByTags;
exports.createServices = createServices;
exports.getServiceInstanceKeys = getServiceInstanceKeys;
exports.getOrCreateServiceKeys = getOrCreateServiceKeys;
const fs = __importStar(require("node:fs"));
const axios_1 = __importDefault(require("axios"));
const path = __importStar(require("node:path"));
const cf_tools_1 = require("@sap/cf-tools");
const btp_utils_1 = require("@sap-ux/btp-utils");
const i18n_1 = require("../../i18n");
const project_1 = require("../project");
const cli_1 = require("./cli");
const PARAM_MAP = new Map([
    ['spaceGuids', 'space_guids'],
    ['planNames', 'service_plan_names'],
    ['names', 'names']
]);
/**
 * Get the business service info.
 *
 * @param {string} businessService - The business service.
 * @param {CfConfig} config - The CF config.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<ServiceInfo | null>} The service info.
 */
async function getBusinessServiceInfo(businessService, config, logger) {
    const serviceKeys = await getServiceInstanceKeys({
        spaceGuids: [config.space.GUID],
        names: [businessService]
    }, logger);
    logger?.log(`Available service key instance : ${JSON.stringify(serviceKeys?.serviceInstance)}`);
    return serviceKeys;
}
/**
 * Get the FDC request arguments.
 *
 * @param {CfConfig} cfConfig - The CF config.
 * @returns {RequestArguments} The request arguments.
 */
function getFDCRequestArguments(cfConfig) {
    const fdcUrl = 'https://ui5-flexibility-design-and-configuration.';
    const cfApiEndpoint = `https://api.cf.${cfConfig.url}`;
    const endpointParts = /https:\/\/api\.cf(?:\.([^-.]*)(-\d+)?(\.hana\.ondemand\.com)|(.*))/.exec(cfApiEndpoint);
    const options = {
        withCredentials: true,
        headers: {
            'Content-Type': 'application/json'
        }
    };
    let url;
    if (endpointParts?.[3]) {
        // Public cloud - use mTLS enabled domain with "cert" prefix
        const region = endpointParts[1];
        url = `${fdcUrl}cert.cfapps.${region}.hana.ondemand.com`;
    }
    else if (endpointParts?.[4]?.endsWith('.cn')) {
        // China has a special URL pattern
        const parts = endpointParts[4].split('.');
        parts.splice(2, 0, 'apps');
        url = `${fdcUrl}sapui5flex${parts.join('.')}`;
    }
    else {
        url = `${fdcUrl}sapui5flex.cfapps${endpointParts?.[4]}`;
    }
    // Add authorization token for non-BAS environments or private cloud
    // For BAS environments with mTLS, the certificate authentication is handled automatically
    if (!(0, btp_utils_1.isAppStudio)() || !endpointParts?.[3]) {
        options.headers['Authorization'] = `Bearer ${cfConfig.token}`;
    }
    return {
        url: url,
        options
    };
}
/**
 * Get the FDC apps.
 *
 * @param {string[]} appHostIds - The app host ids.
 * @param {CfConfig} cfConfig - The CF config.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<CFApp[]>} The FDC apps.
 */
async function getFDCApps(appHostIds, cfConfig, logger) {
    const requestArguments = getFDCRequestArguments(cfConfig);
    logger?.log(`App Hosts: ${JSON.stringify(appHostIds)}, request arguments: ${JSON.stringify(requestArguments)}`);
    const appHostIdParams = appHostIds.map((id) => `appHostId=${encodeURIComponent(id)}`).join('&');
    const url = `${requestArguments.url}/api/business-service/discovery?${appHostIdParams}`;
    try {
        const response = await axios_1.default.get(url, requestArguments.options);
        if (response.status === 200) {
            logger?.log(`Retrieved FDC apps with request url: ${JSON.stringify(response.data)}`);
            return response.data.results;
        }
        else {
            throw new Error((0, i18n_1.t)('error.failedToConnectToFDCService', { status: response.status }));
        }
    }
    catch (error) {
        logger?.error(`Getting FDC apps failed. Request url: ${url}. ${error}`);
        throw new Error((0, i18n_1.t)('error.failedToGetFDCApps', { error: error.message }));
    }
}
/**
 * Creates a service instance.
 *
 * @param {string} plan - The service plan.
 * @param {string} serviceInstanceName - The service instance name.
 * @param {string} serviceName - The service name.
 * @param {CreateServiceOptions} [options] - Additional options.
 * @returns {Promise<void>} The promise.
 */
async function createServiceInstance(plan, serviceInstanceName, serviceName, options) {
    const { xsSecurityProjectName, templatePathOverwrite, logger } = options ?? {};
    try {
        logger?.log(`Creating service instance '${serviceInstanceName}' of service '${serviceName}' with '${plan}' plan`);
        const commandParameters = ['create-service', serviceName, plan, serviceInstanceName];
        if (xsSecurityProjectName) {
            let xsSecurity = null;
            try {
                const baseTmplPath = path.join(__dirname, '../../../templates');
                const templatePath = templatePathOverwrite ?? baseTmplPath;
                const filePath = path.resolve(templatePath, 'cf/xs-security.json');
                const xsContent = fs.readFileSync(filePath, 'utf-8');
                xsSecurity = JSON.parse(xsContent);
                xsSecurity.xsappname = xsSecurityProjectName;
            }
            catch (err) {
                logger?.error(`Failed to parse xs-security.json file: ${err}`);
                throw new Error((0, i18n_1.t)('error.xsSecurityJsonCouldNotBeParsed'));
            }
            commandParameters.push('-c', JSON.stringify(xsSecurity));
        }
        await cf_tools_1.Cli.execute(commandParameters);
        logger?.log(`Service instance '${serviceInstanceName}' created successfully`);
    }
    catch (e) {
        logger?.error(e);
        throw new Error((0, i18n_1.t)('error.failedToCreateServiceInstance', { serviceInstanceName, error: e.message }));
    }
}
/**
 * Gets the service name by tags.
 *
 * @param {string} spaceGuid - The space GUID.
 * @param {string[]} tags - The service tags for discovery.
 * @returns {Promise<string>} The service name.
 */
async function getServiceNameByTags(spaceGuid, tags) {
    const json = await (0, cli_1.requestCfApi)(`/v3/service_offerings?per_page=1000&space_guids=${spaceGuid}`);
    const serviceOffering = json?.resources?.find((resource) => resource.tags && tags.every((tag) => resource.tags?.includes(tag)));
    return serviceOffering?.name ?? '';
}
/**
 * Creates the services.
 *
 * @param {MtaYaml} yamlContent - The YAML content.
 * @param {string[]} initialServices - The initial services.
 * @param {string} timestamp - The timestamp.
 * @param {string} [templatePathOverwrite] - The template path overwrite.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<void>} The promise.
 */
async function createServices(yamlContent, initialServices, timestamp, templatePathOverwrite, logger) {
    const excludeServices = new Set([...initialServices, 'portal', 'html5-apps-repo']);
    const xsSecurityProjectName = (0, project_1.getProjectNameForXsSecurity)(yamlContent, timestamp);
    for (const resource of yamlContent.resources ?? []) {
        if (!excludeServices.has(resource?.parameters?.service ?? '')) {
            if (resource?.parameters?.service === 'xsuaa') {
                await createServiceInstance(resource.parameters['service-plan'] ?? '', resource.parameters['service-name'] ?? '', resource.parameters.service, {
                    xsSecurityProjectName,
                    templatePathOverwrite,
                    logger
                });
            }
            else {
                await createServiceInstance(resource.parameters['service-plan'] ?? '', resource.parameters['service-name'] ?? '', resource.parameters.service ?? '', {
                    templatePathOverwrite,
                    logger
                });
            }
        }
    }
}
/**
 * Gets the service instance keys.
 *
 * @param {GetServiceInstanceParams} serviceInstanceQuery - The service instance query.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<ServiceInfo | null>} The service instance keys.
 */
async function getServiceInstanceKeys(serviceInstanceQuery, logger) {
    try {
        const serviceInstances = await getServiceInstance(serviceInstanceQuery);
        if (serviceInstances?.length > 0) {
            // We can use any instance in the list to connect to HTML5 Repo
            logger?.log(`Use '${serviceInstances[0].name}' HTML5 Repo instance`);
            return {
                serviceKeys: await getOrCreateServiceKeys(serviceInstances[0], logger),
                serviceInstance: serviceInstances[0]
            };
        }
        return null;
    }
    catch (e) {
        const errorMessage = (0, i18n_1.t)('error.failedToGetServiceInstanceKeys', { error: e.message });
        logger?.error(errorMessage);
        throw new Error(errorMessage);
    }
}
/**
 * Gets the service instance.
 *
 * @param {GetServiceInstanceParams} params - The service instance parameters.
 * @returns {Promise<ServiceInstance[]>} The service instance.
 */
async function getServiceInstance(params) {
    const parameters = Object.entries(params)
        .filter(([_, value]) => value?.length > 0)
        .map(([key, value]) => `${PARAM_MAP.get(key)}=${value.join(',')}`);
    const uriParameters = parameters.length > 0 ? `?${parameters.join('&')}` : '';
    const uri = `/v3/service_instances` + uriParameters;
    try {
        const json = await (0, cli_1.requestCfApi)(uri);
        if (!json?.resources || !Array.isArray(json.resources)) {
            throw new Error((0, i18n_1.t)('error.noValidJsonForServiceInstance'));
        }
        return json.resources.map((service) => ({
            name: service.name,
            guid: service.guid
        }));
    }
    catch (e) {
        throw new Error((0, i18n_1.t)('error.failedToGetServiceInstance', { uriParameters, error: e.message }));
    }
}
/**
 * Gets the service instance keys.
 *
 * @param {ServiceInstance} serviceInstance - The service instance.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<ServiceKeys[]>} The service instance keys.
 */
async function getOrCreateServiceKeys(serviceInstance, logger) {
    const serviceInstanceName = serviceInstance.name;
    try {
        const credentials = await (0, cli_1.getServiceKeys)(serviceInstance.guid);
        if (credentials?.length > 0) {
            return credentials;
        }
        else {
            const serviceKeyName = serviceInstanceName + '_key';
            logger?.log(`Creating service key '${serviceKeyName}' for service instance '${serviceInstanceName}'`);
            await (0, cli_1.createServiceKey)(serviceInstanceName, serviceKeyName);
            return (0, cli_1.getServiceKeys)(serviceInstance.guid);
        }
    }
    catch (e) {
        throw new Error((0, i18n_1.t)('error.failedToGetOrCreateServiceKeys', { serviceInstanceName, error: e.message }));
    }
}
//# sourceMappingURL=api.js.map