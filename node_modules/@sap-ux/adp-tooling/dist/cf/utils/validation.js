"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSmartTemplateApplication = validateSmartTemplateApplication;
exports.extractJsonFromZip = extractJsonFromZip;
exports.extractXSApp = extractXSApp;
exports.validateODataEndpoints = validateODataEndpoints;
const i18n_1 = require("../../i18n");
const manifest_1 = require("../../source/manifest");
/**
 * Normalize the xs-app route regex.
 *
 * @param {string} value - The value.
 * @returns {RegExp} The normalized route regex.
 */
function normalizeRouteRegex(value) {
    return new RegExp(value.replace('^/', '^(/)*').replace('/(.*)$', '(/)*(.*)$'));
}
/**
 * Validate the smart template application.
 *
 * @param {Manifest} manifest - The manifest.
 * @returns {Promise<void>} The messages.
 */
async function validateSmartTemplateApplication(manifest) {
    const appType = (0, manifest_1.getApplicationType)(manifest);
    if (!(0, manifest_1.isSupportedAppTypeForAdp)(appType)) {
        throw new Error((0, i18n_1.t)('error.adpDoesNotSupportSelectedApplication'));
    }
    if (manifest['sap.ui5']?.flexEnabled === false) {
        throw new Error((0, i18n_1.t)('error.appDoesNotSupportFlexibility'));
    }
}
/**
 * Generic function to extract and parse JSON from zip entries.
 *
 * @param {AdmZip.IZipEntry[]} zipEntries - The zip entries.
 * @param {string} fileName - The file name to find (e.g., 'manifest.json', 'xs-app.json').
 * @param {string} errorKey - The i18n error key for parsing failures.
 * @returns {T | undefined} The parsed JSON object.
 */
function extractJsonFromZip(zipEntries, fileName, errorKey) {
    const entry = zipEntries.find((item) => item.entryName.endsWith(fileName));
    try {
        return JSON.parse(entry?.getData().toString('utf8') ?? '');
    }
    catch (e) {
        throw new Error((0, i18n_1.t)(errorKey, { error: e.message }));
    }
}
/**
 * Extract the xs-app.json from the zip entries.
 *
 * @param {AdmZip.IZipEntry[]} zipEntries - The zip entries.
 * @returns {XsApp | undefined} The xs-app.json.
 */
function extractXSApp(zipEntries) {
    return extractJsonFromZip(zipEntries, 'xs-app.json', 'error.failedToParseXsAppJson');
}
/**
 * Extract the manifest.json from the zip entries.
 *
 * @param {AdmZip.IZipEntry[]} zipEntries - The zip entries.
 * @returns {Manifest | undefined} The manifest.
 */
function extractManifest(zipEntries) {
    return extractJsonFromZip(zipEntries, 'manifest.json', 'error.failedToParseManifestJson');
}
/**
 * Match the routes and data sources.
 *
 * @param {Record<string, ManifestNamespace.DataSource>} dataSources - The data sources from manifest.json.
 * @param {XsAppRoute[]} routes - The routes from xs-app.json.
 * @param {string[]} serviceKeyEndpoints - The service key endpoints.
 * @returns {string[]} The messages.
 */
function matchRoutesAndDatasources(dataSources, routes, serviceKeyEndpoints) {
    const messages = [];
    for (const route of routes) {
        if (route.endpoint && !serviceKeyEndpoints.includes(route.endpoint)) {
            messages.push(`Route endpoint '${route.endpoint}' doesn't match a corresponding OData endpoint`);
        }
    }
    for (const dataSourceName of Object.keys(dataSources ?? {})) {
        if (!routes.some((route) => dataSources?.[dataSourceName].uri?.match(normalizeRouteRegex(route.source)))) {
            messages.push(`Data source '${dataSourceName}' doesn't match a corresponding route in xs-app.json routes`);
        }
    }
    return messages;
}
/**
 * Validate the OData endpoints, data sources and routes.
 *
 * @param {AdmZip.IZipEntry[]} zipEntries - The zip entries.
 * @param {ServiceKeys[]} serviceKeys - The service keys.
 * @param {ToolsLogger} logger - The logger.
 * @returns {Promise<string[]>} The messages.
 */
async function validateODataEndpoints(zipEntries, serviceKeys, logger) {
    const messages = [];
    let xsApp;
    try {
        xsApp = extractXSApp(zipEntries);
        logger?.log(`ODATA endpoints: ${JSON.stringify(xsApp)}`);
    }
    catch (error) {
        messages.push(error);
    }
    let manifest;
    try {
        manifest = extractManifest(zipEntries);
        logger?.log(`Extracted manifest: ${JSON.stringify(manifest)}`);
    }
    catch (error) {
        messages.push(error);
    }
    const dataSources = manifest?.['sap.app']?.dataSources;
    const routes = xsApp?.routes;
    if (dataSources && routes) {
        const serviceKeyEndpoints = [].concat(...serviceKeys.map(({ credentials }) => (credentials.endpoints ? Object.keys(credentials.endpoints) : [])));
        messages.push(...matchRoutesAndDatasources(dataSources, routes, serviceKeyEndpoints));
    }
    else if (routes && !dataSources) {
        messages.push("Base app manifest.json doesn't contain data sources specified in xs-app.json");
    }
    else if (!routes && dataSources) {
        messages.push("Base app xs-app.json doesn't contain data sources routes specified in manifest.json");
    }
    if (messages.length > 0) {
        const errorMessages = messages.join('\n');
        logger?.error(`OData endpoints validation failed:\n${errorMessages}`);
        throw new Error((0, i18n_1.t)('error.oDataEndpointsValidationFailed'));
    }
}
//# sourceMappingURL=validation.js.map