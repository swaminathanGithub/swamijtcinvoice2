"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformationsRequiredForAnalyticalTable = void 0;
exports.findEntitySetByName = findEntitySetByName;
exports.hasAggregateTransformations = hasAggregateTransformations;
exports.filterAggregateTransformations = filterAggregateTransformations;
exports.hasAggregateTransformationsForEntitySet = hasAggregateTransformationsForEntitySet;
exports.hasAggregateTransformationsForEntity = hasAggregateTransformationsForEntity;
exports.hasRecursiveHierarchyForEntitySet = hasRecursiveHierarchyForEntitySet;
exports.getRecursiveHierarchyQualifierForEntitySet = getRecursiveHierarchyQualifierForEntitySet;
exports.hasRecursiveHierarchyForEntity = hasRecursiveHierarchyForEntity;
exports.getRecursiveHierarchyQualifier = getRecursiveHierarchyQualifier;
exports.shouldUseAnalyticalTable = shouldUseAnalyticalTable;
exports.convertEdmxToConvertedMetadata = convertEdmxToConvertedMetadata;
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const i18n_1 = require("../i18n");
/**
 * Required transformations for analytical table support.
 * NOTE: This constant is primarily used by odata-service-inquirer but is exported
 * here to maintain backward compatibility with external packages that import it.
 */
exports.transformationsRequiredForAnalyticalTable = [
    'filter',
    'identity',
    'orderby',
    'skip',
    'top',
    'groupby',
    'aggregate',
    'concat'
];
/**
 * Annotation pattern for RecursiveHierarchy.
 */
const RECURSIVE_HIERARCHY_ANNOTATION = 'RecursiveHierarchy';
/**
 * Finds an entity set by name in the metadata.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The name of the entity set to find.
 * @returns The entity set if found, undefined otherwise.
 */
function findEntitySetByName(metadata, entitySetName) {
    return metadata.entitySets.find((entitySet) => entitySet.name === entitySetName);
}
/**
 * Checks if the given entity set has aggregate transformations.
 * Returns true if ANY transformations are present in either entity set or entity type annotations.
 *
 * @param entitySet The entity set to check for aggregate transformations.
 * @returns true if the entity set has any aggregate transformations, false otherwise.
 */
function hasAggregateTransformations(entitySet) {
    const transformations = entitySet.annotations?.Aggregation?.ApplySupported?.Transformations ||
        entitySet.entityType?.annotations?.Aggregation?.ApplySupported?.Transformations;
    return Array.isArray(transformations) && transformations.length > 0;
}
/**
 * Returns only entity sets that have the `Aggregation.ApplySupported` annotation term with the `Transformations` property.
 * This can be found within the entity set annotations or the entity type annotations.
 *
 * @param entitySets the entity sets to filter
 * @returns the filtered entity sets
 */
function filterAggregateTransformations(entitySets) {
    return entitySets.filter(hasAggregateTransformations);
}
/**
 * Checks if the given entity set has aggregate transformations.
 * If specific transformations are provided, checks if ALL of those transformations are present.
 * If no transformations are specified, returns true if ANY transformations are present.
 *
 * @param entitySet The entity set to check for aggregate transformations.
 * @param requiredTransformations Optional array of specific transformations to check for. If not provided, checks for any transformations.
 * @returns true if the entity set has the required transformations, false otherwise.
 */
function hasAggregateTransformationsForEntitySet(entitySet, requiredTransformations) {
    const transformations = entitySet.annotations?.Aggregation?.ApplySupported?.Transformations ||
        entitySet.entityType?.annotations?.Aggregation?.ApplySupported?.Transformations;
    if (!Array.isArray(transformations)) {
        return false;
    }
    // If no specific transformations required, return true if any transformations exist
    if (!requiredTransformations || requiredTransformations.length === 0) {
        return transformations.length > 0;
    }
    // Check if all required transformations are present
    return requiredTransformations.every((transformation) => transformations.includes(transformation));
}
/**
 * Checks if the given entity set name has aggregate transformations in the metadata.
 * If specific transformations are provided, checks if ALL of those transformations are present.
 * If no transformations are specified, returns true if ANY transformations are present.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The entity set name to check for aggregate transformations.
 * @param requiredTransformations Optional array of specific transformations to check for. If not provided, checks for any transformations.
 * @returns true if the entity set has the required transformations, false otherwise.
 */
function hasAggregateTransformationsForEntity(metadata, entitySetName, requiredTransformations) {
    const entitySet = findEntitySetByName(metadata, entitySetName);
    if (!entitySet) {
        return false;
    }
    return hasAggregateTransformationsForEntitySet(entitySet, requiredTransformations);
}
/**
 * Finds the RecursiveHierarchy annotation key for the given entity set.
 * This is a helper function that both existence check and qualifier extraction can use.
 *
 * @param entitySet The entity set to check for recursive hierarchy annotation.
 * @returns The RecursiveHierarchy key if found, undefined otherwise.
 */
function findRecursiveHierarchyKey(entitySet) {
    const hierarchyAnnotations = entitySet?.entityType?.annotations?.Hierarchy;
    if (!hierarchyAnnotations) {
        return undefined;
    }
    // First try exact match for the most common case
    if (hierarchyAnnotations[RECURSIVE_HIERARCHY_ANNOTATION]) {
        return RECURSIVE_HIERARCHY_ANNOTATION;
    }
    // Then check for qualified versions (RecursiveHierarchy#qualifier)
    return Object.keys(hierarchyAnnotations).find((key) => key.startsWith(RECURSIVE_HIERARCHY_ANNOTATION));
}
/**
 * Checks if the given entity set has a Hierarchy.RecursiveHierarchy annotation.
 *
 * @param entitySet The entity set to check for recursive hierarchy annotation.
 * @returns true if the entity set has Hierarchy.RecursiveHierarchy annotation, false otherwise.
 */
function hasRecursiveHierarchyForEntitySet(entitySet) {
    return !!findRecursiveHierarchyKey(entitySet);
}
/**
 * Gets the qualifier from a Hierarchy.RecursiveHierarchy annotation for the given entity set.
 *
 * @param entitySet The entity set to check for recursive hierarchy annotation.
 * @returns The qualifier string if found, undefined otherwise.
 */
function getRecursiveHierarchyQualifierForEntitySet(entitySet) {
    return findRecursiveHierarchyKey(entitySet)?.split('#')[1];
}
/**
 * Checks if the given entity set name has a Hierarchy.RecursiveHierarchy annotation in the metadata.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The entity set name to check for recursive hierarchy annotation.
 * @returns true if the entity set has Hierarchy.RecursiveHierarchy annotation, false otherwise.
 */
function hasRecursiveHierarchyForEntity(metadata, entitySetName) {
    const entitySet = findEntitySetByName(metadata, entitySetName);
    if (!entitySet) {
        return false;
    }
    return hasRecursiveHierarchyForEntitySet(entitySet);
}
/**
 * Gets the qualifier from a Hierarchy.RecursiveHierarchy annotation for the given entity set.
 *
 * @param metadata The metadata (edmx) of the service.
 * @param entitySetName The entity set name to check for recursive hierarchy annotation.
 * @returns The qualifier string if found, undefined otherwise.
 */
function getRecursiveHierarchyQualifier(metadata, entitySetName) {
    const entitySet = findEntitySetByName(metadata, entitySetName);
    if (!entitySet) {
        return undefined;
    }
    return getRecursiveHierarchyQualifierForEntitySet(entitySet);
}
/**
 * Determines if AnalyticalTable should be used based on entity annotations and transformation requirements.
 *
 * AnalyticalTable is used when entity has analytical data and meets the specified transformation requirements.
 *
 * @param entitySet The entity set to check for annotations.
 * @param requireCompleteTransformations Whether to require all analytical transformations or accept any analytical annotations.
 * @returns True if AnalyticalTable should be used, false otherwise.
 */
function shouldUseAnalyticalTable(entitySet, requireCompleteTransformations) {
    // No analytical data means no need for AnalyticalTable
    if (!hasAggregateTransformations(entitySet)) {
        return false;
    }
    // If complete transformations are not required, any analytical annotations are sufficient
    if (!requireCompleteTransformations) {
        return true;
    }
    // Require complete analytical transformations
    return hasAggregateTransformationsForEntitySet(entitySet, exports.transformationsRequiredForAnalyticalTable);
}
/**
 * Converts an EDMX string to a ConvertedMetadata object.
 *
 * @param edmx - The EDMX string to convert.
 * @returns The converted metadata object.
 * @throws If the EDMX cannot be parsed or the OData version is unparseable.
 */
function convertEdmxToConvertedMetadata(edmx) {
    try {
        const convertedMetadata = (0, annotation_converter_1.convert)((0, edmx_parser_1.parse)(edmx));
        const parsedOdataVersion = Number.parseInt(convertedMetadata?.version, 10);
        if (Number.isNaN(parsedOdataVersion)) {
            throw new TypeError((0, i18n_1.t)('errors.unparseableOdataVersion'));
        }
        return convertedMetadata;
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error((0, i18n_1.t)('errors.unparseableMetadata', { error: errorMessage }));
    }
}
//# sourceMappingURL=metadataHelpers.js.map