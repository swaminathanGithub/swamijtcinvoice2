"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SystemService = void 0;
exports.getInstance = getInstance;
const backend_system_1 = require("../data-provider/backend-system");
const backend_system_2 = require("../entities/backend-system");
const i18n_1 = require("../i18n");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
/**
 * Should not be used directly, use factory method `getService` instead.
 * Data integrity cannot be guaranteed when using this class directly.
 */
class SystemService {
    dataProvider;
    logger;
    constructor(logger, options = {}) {
        this.logger = logger;
        this.dataProvider = new backend_system_1.SystemDataProvider(this.logger, options);
    }
    async partialUpdate(key, entity) {
        this.validatePartialUpdateInput(entity);
        const existingSystem = await this.readOrThrow(key);
        const updatedEntity = this.mergeProperties(entity, existingSystem);
        return this.write(updatedEntity, {
            force: true
        });
    }
    mergeProperties(update, existingSystem) {
        const patch = { ...update };
        // Make sure we don't mess with key fields
        delete patch.url;
        delete patch.client;
        const updatedEntity = { ...existingSystem, ...patch };
        return new backend_system_2.BackendSystem({ ...updatedEntity });
    }
    async readOrThrow(key) {
        const existingSystem = await this.read(key);
        if (!existingSystem) {
            throw new Error((0, i18n_1.text)('error.systemDoesNotExist', { system: key }));
        }
        return existingSystem;
    }
    validatePartialUpdateInput(entity) {
        if (!entity || !Object.keys(entity).length) {
            throw new Error((0, i18n_1.text)('error.noPropertiesSpecified'));
        }
    }
    async read(key) {
        return this.dataProvider.read(key);
    }
    /**
     * Write the backend system to the store. If a backend entity with the same key already exists and error is thrown.
     * Use the `force` option to overwrite, use with cautions and are sure other clients will not break.
     *
     * @param entity the backend system to write
     * @param options
     * @param options.force Force overwrite existing backend system with the same key
     * @returns
     */
    async write(entity, options) {
        // Prevent overwrite of existing entity with the same key unless explicitly forced
        const entityKey = backend_system_2.BackendSystemKey.from(entity);
        const existingSystem = await this.read(backend_system_2.BackendSystemKey.from(entity));
        if (!options?.force && existingSystem) {
            throw new Error((0, i18n_1.text)('error.backendSystemEntityKeyExists', { entityKey: entityKey.getId() }));
        }
        return this.dataProvider.write(entity);
    }
    async delete(entity) {
        return this.dataProvider.delete(entity);
    }
    async getAll(options) {
        return this.dataProvider.getAll(options);
    }
}
exports.SystemService = SystemService;
function getInstance(logger, options = {}) {
    if (!options.baseDirectory) {
        try {
            ensureSystemsJsonMigrated();
        }
        catch (error) {
            logger.error((0, i18n_1.text)('error.systemsJsonMigrationFailed', { error: error.message }));
        }
        options.baseDirectory = (0, utils_1.getSapToolsDirectory)();
    }
    return new SystemService(logger, options);
}
/**
 * Ensure settings are migrated from .fioritools directory to the new .saptools directory.
 * If the migration has already taken place, we still check if new systems have been added (possibly via an older version of this module)
 * We then migrate only these new systems.
 */
function ensureSystemsJsonMigrated() {
    const systemFileName = (0, utils_1.getEntityFileName)(constants_1.Entity.BackendSystem);
    const legacySystemsPath = (0, node_path_1.join)((0, utils_1.getFioriToolsDirectory)(), systemFileName);
    const newSystemsPath = (0, node_path_1.join)((0, utils_1.getSapToolsDirectory)(), systemFileName);
    const migrationFlag = (0, node_path_1.join)((0, utils_1.getSapToolsDirectory)(), '.systemsMigrated');
    const legacyData = JSON.parse((0, node_fs_1.readFileSync)(legacySystemsPath, 'utf-8')).systems;
    if ((0, node_fs_1.existsSync)(migrationFlag)) {
        migrateNewLegacyPathEntries(newSystemsPath, legacyData);
    }
    else {
        // first time migration, move all data from legacy to new path
        (0, node_fs_1.mkdirSync)((0, node_path_1.dirname)(newSystemsPath), { recursive: true });
        (0, node_fs_1.writeFileSync)(newSystemsPath, JSON.stringify({ systems: legacyData }, null, 2));
        (0, node_fs_1.writeFileSync)(migrationFlag, new Date().toISOString());
    }
    // overwrite legacy file entries with migrated flag to avoid re-migration
    const migratedData = {};
    for (const [key, system] of Object.entries(legacyData)) {
        migratedData[key] = {
            ...system,
            _migrated: true
        };
    }
    (0, node_fs_1.writeFileSync)(legacySystemsPath, JSON.stringify({ systems: { ...migratedData } }, null, 2));
}
/**
 * Migrates new entries in the systems.json in the legacy path, that have not yet been migrated.
 *
 * @param newSystemsPath - path to the new systems.json file
 * @param legacyData - data from the legacy systems.json file
 */
function migrateNewLegacyPathEntries(newSystemsPath, legacyData) {
    let hasNewEntries = false;
    const newData = {};
    for (const [key, system] of Object.entries(legacyData)) {
        if (!system._migrated) {
            newData[key] = {
                ...system
            };
            hasNewEntries = true;
        }
    }
    if (hasNewEntries) {
        const existingData = JSON.parse((0, node_fs_1.readFileSync)(newSystemsPath, 'utf-8')).systems;
        (0, node_fs_1.writeFileSync)(newSystemsPath, JSON.stringify({ systems: { ...existingData, ...newData } }, null, 2));
    }
}
//# sourceMappingURL=backend-system.js.map